<!DOCTYPE html>
<html>
<head>
	<link rel="stylesheet" href="css/bootstrap.css">
	<link rel="stylesheet" href="css/prettify.css">
	<script src="js/jquery-1.9.0.min.js"></script>
	<script src="js/prettify.js"></script>

	<script>
		

	</script>
</head>
<body onload="prettyPrint()">
	<div class="container">
		<div style="margin-top:20px" class="hero-unit">
			<div class="row">
				<div class="span-6">
					<h1>JavaScript prototype tutorial</h1>
					<p ><br/>Because the JavaScript prototype pattern sucks.<br/>
						<a href="https://process-smith.com">As used in Process Smith</a>
					</p>
					
				</div>
				<div class="span-4 pull-right">
					<!--<img width=200 src="img/comment.png"/>-->
				</div>
			</div>
			
		</div>
		<div class="span8">
		<h3>Simplifying inheritance in JavaScript</h3>
		<p>
			The JavaScript prototype pattern is one of the most confusing aspects of the JavaScript language. That being said, inheritance is a very useful pattern, so figuring out how to do it is important if you want to write powerful applications. JavaScript is also a very malleable language, so there are more than one way to achieve inheritance.
		</p>

		<p>
			Since the prototype pattern is so confusing, I would recommend against using the raw prototype property because there are cleaner solutions to the inheritance problem. In general I try to stay away from any coding patterns that are confusing or not well understood, since it makes more code more readable and bug free. The two solutions for implementing inheritance in JavaScript that I find cleaner are Underscore.js's "extend" method and Prototype.js "Class".   
		</p>

		<p>
			<ul>
				<li><a href="http://underscorejs.org/#extend">Underscore.js "extend"</a> Combines a parent and child objects into a new object where  properties in the parent object are overwritten by the child object.</li>
				<li><a href="http://prototypejs.org/learn/class-inheritance.html">Prototype.js "Class"</a> A wrapper around JavaScript's prototype that makes JavaScript inheritance more like traditional inheritance. </li>
			</ul>
		</p>

		<p>
			These two approaches can be a solution to most problems where inheritance in needed. There are still a few scenarios where using JavaScript's prototype inheritance is the best solution.
			<ol>
				<li>Reducing memory footprint: In the prototype pattern objects that inherit from a prototype share one object.</li>
				<li>Properties of a super class changing after construction.</li>
				<li>To impress people in JavaScript interviews: Since the prototype is so confusing and involves low level knowledge of the language it is often used as a barometer of one's JavaScript knowledge in interviews.  </li>
			</ol>
		</p>

		<h3>Prototypical inheritance</h3>
		<p>
			In prototypical inheritance, inheritance is achieved by looking at an object's prototype if the property does not exist in the given object. The difference between prototypical inheritance and traditional inheritance is that the prototype must be an actual object and not an abstract class. For example, in Java you don't need to create a new object of a class to inherit from, in JavaScript you must create an actual object to set a prototype.
		</p>

		<h3>prototype function property</h3>

		<p>
			Setting the prototype property of a function is the most traditional prototype pattern. It should be noted this is the only prototype pattern that works on modern browsers and older IE browsers.  
		</p>

		<p>
			In this pattern an initial function is created that will later be inherited from, called Bar. To set a prototype it must take an object, so we must initialize a new Bar. I call this barProto. Then we must define the Foo function and set its prototype to barProto. Now we can initialize a new Foo and its prototype will be set to Bar. 
		</p>
			<pre class="prettyprint">
var Bar = function(){
   this.name='Bar'
}
var barProto = new Bar()  
var Foo = function(){
}
Foo.prototype= barProto
var foo = new Foo()
console.log(foo.name) // Bar
			</pre>
		<p>
			You can see the the <code>var Foo = function()</code> does not have a <code>name</code> property. However, Bar does have the <code>name</code> property. At runtime JavaScript first tries to get <code>name</code> from foo, it does not exist so it then checks foo's prototype barProto for name. It does exist, so <code>foo.name</code> will get 'Bar' from <code>barProto</code>.
		</p>

		<p>
			The most confusing part of this pattern is understanding what the prototype property actually is. It is not like any other property in JavaScript because how the <code>new</code> keyword effects Foo during construction. Remember when <code>new</code> is used <code>this</code> inside the function is the new object that is being created. When the actual new object is created by JavaScript from a function the prototype property of the function is looked at to set the object that is that is  <code>this</code> new object is inherited from. In modern browsers the function's prototype property is the same object that is in the new objects <code>__proto__</code> property. However, in IE &lt; 9 this is not the case.
		</p>

		<h3>__proto__ object property</h3>

		<p>
			Accessing the <code>__proto__</code> of an object skips the process described in the previous prototype property section.
		</p>

		<h3>Object.create</h3>

		<div>
</body>
</html>